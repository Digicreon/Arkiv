#!/bin/bash

# ARKIV
#
# Simple file archiver, designed to backup local files and MySQL databases and archive them on Amazon S3.
#
# Source code and documentation: https://github.com/Amaury/Arkiv
#
# © 2017, Amaury Bouchard <amaury@amaury.net>
#
# @see	Getopts: https://stackoverflow.com/questions/402377/using-getopts-in-bash-shell-script-to-get-long-and-short-command-line-options/7680682#7680682
# @see	Encryption: https://superuser.com/questions/724986/how-to-use-password-argument-in-via-command-line-to-openssl-for-decryption

# ########## GLOBAL VARIABLES ##########

# Path to the configuration file.
# @see	main_usage()
CONFIG_FILE_PATH="~/.arkiv"

# Path to the log file
# @see	main_usage()
OPT_LOG_PATH=""

# no-ansi mode
# @see	main_usage()
OPT_NOANSI=0

# no-stdout mode
# @see	main_usage()
OPT_NOSTDOUT=0

# no-stderr mode
# @see	main_usage()
OPT_NOSTDERR=0

# Write to syslog option.
# @see	main_usage()
OPT_SYSLOG=0


# ########## FUNCTIONS ##########

# trim()
# Remove spaces at the beginning and at the end of a character string.
# @param	string	The string to trim.
trim() {
	RESULT=$(echo "$1" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
	echo $RESULT
}

# filenamize()
# Convert a string that contains a path to a file, and return a string suitable as a file name.
# Replace slashes and spaces by dashes.
# @param	string	The string to modify.
filenamize() {
	RESULT=$(echo "$1" | sed 's/[[:space:]]\+/-/g' | sed 's/\//-/g' | sed -e 's/^-*//' -e 's/-*$//' | sed 's/-\+/-/g')
	echo $RESULT
}

# ansi()
# Write ANSI-compatible statements.
# @param	string	Command:
#			- reset: Remove all decoration.
#			- bold:  Write text in bold.
#			- dim:   Write faint text.
#			- rev:   Write text in reverse video. Could take another parameter with the background color.
#			- under: Write underlined text.
#			- black, red, green, yellow, blue, magenta, cyan, white: Change the text color.
ansi() {
	if [ "$TERM" = "" ] || [ "$OPT_NOANSI" = "1" ]; then
		return
	fi
	if ! type tput > /dev/null; then
		return
	fi
	case "$1" in
		"reset")	tput sgr0
		;;
		"bold")		tput bold
		;;
		"dim")		tput dim
		;;
		"rev")
			case "$2" in
				"black")	tput setab 0
				;;
				"red")		tput setab 1
				;;
				"green")	tput setab 2
				;;
				"yellow")	tput setab 3
				;;
				"blue")		tput setab 4
				;;
				"magenta")	tput setab 5
				;;
				"cyan")		tput setab 6
				;;
				"white")	tput setab 7
				;;
				*)		tput rev
			esac
		;;
		"under")	tput smul
		;;
		"black")	tput setaf 0
		;;
		"red")		tput setaf 1
		;;
		"green")	tput setaf 2
		;;
		"yellow")	tput setaf 3
		;;
		"blue")		tput setaf 4
		;;
		"magenta")	tput setaf 5
		;;
		"cyan")		tput setaf 6
		;;
		"white")	tput setaf 7
		;;
	esac
}

# log()
# Write a character string with the current date before it to stdout or to the log file.
# @param	string	The text to write.
log() {
	if [ "$1" = "-n" ]; then
		STR="$2"
	else
		STR="$(ansi dim)[$(date +"%Y-%m-%d %H:%M:%S%:z")]$(ansi reset) $1"
	fi
	# write to stdout unless it is disabled
	if [ "$OPT_NOSTDOUT" != "1" ]; then
		echo $STR
	fi
	# write to log file
	if [ "$OPT_LOG_PATH" != "" ]; then
		echo "$STR" >> "$(eval realpath "$OPT_LOG_PATH")"
	fi
	# write to syslog
	if [ "$OPT_SYSLOG" = "1" ]; then
		logger --tag arkiv --priority user.warning "$TXT"
	fi
}

# err()
# Write a character string with the current date before it to stderr or to the log file.
# @param	string	The text to write.
err() {
	CURDATE=$(date +"%Y-%m-%d %H:%M:%S%:z")
	STR="$(ansi dim)[$CURDATE]$(ansi reset) $1"
	# write to stderr unless it is disabled
	if [ "$OPT_NOSTDOUT" != "1" ]; then
		(>&2 echo "$STR")
	fi
	# write to log file
	if [ "$OPT_LOG_PATH" != "" ]; then
		echo "$STR" >> "$(eval realpath "$OPT_LOG_PATH")"
	fi
	# write to syslog
	if [ "$OPT_SYSLOG" = "1" ]; then
		logger --tag arkiv --priority user.warning "$TXT"
	fi
}

# main_usage()
# Show help and exit.
main_usage() {
	echo
	echo "$(ansi bold)NAME$(ansi reset)"
	echo "        $(ansi bold)Arkiv$(ansi reset) − Backup and archiving tool"
	echo
	echo "$(ansi bold)SYNOPSIS$(ansi reset)"
	echo "        $(ansi bold)arkiv$(ansi reset) help$(ansi dim)|$(ansi reset)config$(ansi dim)|$(ansi reset)exec [-c|--config$(ansi dim)=/path/to/config/file$(ansi reset)] [-l|--log$(ansi dim)=/path/to/log/file$(ansi reset)] [-o|--no-stdout] [-e|--no-stderr] [-n|--noansi] [-s|--syslog]"
	echo
	echo "$(ansi bold)DESCRIPTION$(ansi reset)"
	echo "        $(ansi bold)Arkiv$(ansi reset) is an easy-to-use tool which provides files and MySQL databases backup, and archiving to Amazon S3 and Amazon Glacier."
	echo
	echo "$(ansi bold)MAIN USAGE$(ansi reset)"
	echo "        $(ansi bold)help$(ansi reset)"
	echo "                Display this help."
	echo "        $(ansi bold)config$(ansi reset)"
	echo "                Create Arkiv's configuration file."
	echo "        $(ansi bold)exec$(ansi reset)"
	echo "                Backup files and databases, archive them and purge old files."
	echo
	echo "$(ansi bold)PARAMETERS$(ansi reset)"
	echo "              $(ansi bold)-c$(ansi reset) $(ansi dim)/path/to/config/file$(ansi reset)"
	echo "        $(ansi bold)--config$(ansi reset)$(ansi dim)=/path/to/config/file$(ansi reset)"
	echo "                Path to the configuration file to use instead of '~/.arkiv'."
	echo
	echo "           $(ansi bold)-l$(ansi reset) $(ansi dim)/path/to/log/file$(ansi reset)"
	echo "        $(ansi bold)--log$(ansi reset)$(ansi dim)=/path/to/log/file$(ansi reset)"
	echo "                Path to the log file to use."
	echo
	echo "        $(ansi bold)-o, --no-stdout$(ansi reset)"
	echo "                Don't write informational log messages to STDOUT. If the log file is defined (option --log), messages will be written there anyway."
	echo
	echo "        $(ansi bold)-e, --no-stderr$(ansi reset)"
	echo "                Don't write error log messages to STDERR. If the log file is defined (option --log), messages will be written there anyway."
	echo
	echo "        $(ansi bold)-n, --no-ansi$(ansi reset)"
	echo "                Don't use ANSI commands to ouput decorated text (colors, bold, reverse video)."
	echo
	echo "        $(ansi bold)-s, --syslog$(ansi reset)"
	echo "                Write logs also to syslog."
	echo
	echo "$(ansi bold)SEE ALSO$(ansi reset)"
	echo "        More documentation available on GitHub: $(ansi under)https://github.com/Amaury/Arkiv$(ansi reset)"
	echo
	exit 0
}

# _create_config()
# Create the content of the configuration file.
# Uses the global variables defined elsewhere ($CONF_LOCAL_HOSTNAME, $CONF_BACKUP_PATH, etc.).
# @param	string	(optional) Visibility. Replace the MySQL password by an informative message if this parameter is set to "hide".
_create_config() {
	RESULT="CONF_LOCAL_HOSTNAME=\"$CONF_LOCAL_HOSTNAME\"
CONF_Z_TYPE=\"$CONF_Z_TYPE\""
	if [ "$CONF_ENCRYPT" = "key" ] || [ "$CONF_ENCRYPT" = "pass" ]; then
		RESULT="$RESULT
CONF_ENCRYPT=\"$CONF_ENCRYPT\""
		if [ "$CONF_ENCRYPT" = "key" ]; then
			RESULT="$RESULT
CONF_ENCRYPT_KEY=\"$CONF_ENCRYPT_KEY\""
		else
			RESULT="$RESULT
CONF_ENCRYPT_PASS=\"$CONF_ENCRYPT_PASS\""
		fi
	fi
	RESULT="$RESULT
CONF_BACKUP_PATH=\"$CONF_BACKUP_PATH\"
CONF_SRC=\"$CONF_SRC\"
CONF_MYSQL=\"$CONF_MYSQL\""
	if [ "$CONF_MYSQL" != "no" ]; then
		RESULT="$RESULT
CONF_MYSQL_HOST=\"$CONF_MYSQL_HOST\"
CONF_MYSQL_USER=\"$CONF_MYSQL_USER\""
		if [ "$1" = "hide" ]; then
			RESULT="$RESULT
CONF_MYSQL_PWD=___HIDDEN_PASSWORD___"
		else
			RESULT="$RESULT
CONF_MYSQL_PWD=\"$CONF_MYSQL_PWD\""
		fi
		if [ "$CONF_MYSQL" = "mysqldump" ]; then
			RESULT="$RESULT
CONF_MYSQL_ALL_DATABASES=\"$CONF_MYSQL_ALL_DATABASES\""
			if [ "$CONF_MYSQL_ALL_DATABASES" = "no" ]; then
				RESULT="$RESULT
CONF_MYSQL_DATABASES=\"$CONF_MYSQL_DATABASES\""
			fi
		fi
		if [ "$CONF_MYSQL" = "xtrabackup" ]; then
			RESULT="$RESULT
CONF_XTRABACKUP_TYPE=\"$CONF_XTRABACKUP_TYPE\"
CONF_XTRABACKUP_LSN_FILE=\"$CONF_XTRABACKUP_LSN_FILE\""
		fi
	fi
	RESULT="$RESULT
CONF_AWS_S3=\"$CONF_AWS_S3\""
	if [ "$CONF_AWS_S3" = "yes" ]; then
		RESULT="$RESULT
CONF_S3_BUCKET=\"$CONF_S3_BUCKET\""
	fi
	RESULT="$RESULT
CONF_AWS_GLACIER=\"$CONF_AWS_GLACIER\""
	if [ "$CONF_AWS_GLACIER" = "yes" ]; then
		RESULT="$RESULT
CONF_GLACIER_VAULT=\"$CONF_GLACIER_VAULT\""
	fi
	RESULT="$RESULT
CONF_LOCAL_PURGE_DELAY=\"$CONF_LOCAL_PURGE_DELAY\""
	if [ "$CONF_AWS_S3" = "yes" ]; then
		RESULT="$RESULT
CONF_S3_PURGE_DELAY=\"$CONF_S3_PURGE_DELAY\""
	fi
	echo "$RESULT"
}

# main_config()
# Manage configuration.
main_config() {
	# splashscreen
	echo
	echo " $(ansi rev)                                         $(ansi reset)"
	echo " $(ansi rev) $(ansi reset)$(ansi rev blue)                                       $(ansi reset)$(ansi rev) $(ansi reset)"
	echo " $(ansi rev) $(ansi reset)$(ansi rev blue)          $(ansi white)$(ansi bold)Arkiv Configuration$(ansi reset)$(ansi rev blue)          $(ansi reset)$(ansi rev) $(ansi reset)"
	echo " $(ansi rev) $(ansi reset)$(ansi rev blue)                                       $(ansi reset)$(ansi rev) $(ansi reset)"
	echo " $(ansi rev)                                         $(ansi reset)"
	echo
	# BASIC
	echo "$(ansi rev yellow) BASIC                   $(ansi reset)"
	# simple mode
	read -p " $(ansi yellow)Do you want to set up Arkiv's simple mode? (one backup per day, every day) [Y/n]$(ansi reset) " ANSWER
	SIMPLE_MODE=$(trim "$ANSWER")
	if [ "$SIMPLE_MODE" = "" ] || [ "$SIMPLE_MODE" = "y" ] || [ "$SIMPLE_MODE" = "Y" ]; then
		SIMPLE_MODE="yes"
	elif [ "$SIMPLE_MODE" = "n" ] || [ "$SIMPLE_MODE" = "N" ]; then
		SIMPLE_MODE="no"
	else
		echo " $(ansi red)⛔ Bad value. ABORT$(ansi reset)"
		exit 1
	fi
	# local host
	HOST=$(hostname)
	if [ "$HOST" = "" ]; then
		HOST="localhost"
	fi
	read -p " $(ansi yellow)Local host name? [$HOST]$(ansi reset) " ANSWER
	CONF_LOCAL_HOSTNAME=$(trim "$ANSWER")
	if [ "$CONF_LOCAL_HOSTNAME" = "" ]; then
		CONF_LOCAL_HOSTNAME="$HOST"
	fi
	# compression type
	read -p " $(ansi yellow)Compression type? (gzip|bzip2|xz|zstd) [zstd]$(ansi reset) " ANSWER
	CONF_Z_TYPE=$(trim "$ANSWER")
	if [ "$CONF_Z_TYPE" != "gzip" ] && [ "$CONF_Z_TYPE" != "bzip2" ] && [ "$CONF_Z_TYPE" != "xz" ]; then
		if [ "$CONF_Z_TYPE" != "" ] && [ "$CONF_Z_TYPE" != "zstd" ]; then
			echo " $(ansi red)⛔ Bad value. ABORT$(ansi reset)"
			exit 1
		fi
		CONF_Z_TYPE="zstd"
	fi
	# encryption
	read -p " $(ansi yellow)Do you want to encrypt data? [y/N]$(ansi reset) " ANSWER
	if [ "$ANSWER" = "y" ] || [ "$ANSWER" = "Y" ]; then
		# check openssl
		if ! type openssl > /dev/null; then
			echo " $(ansi red)⛔ The 'AWS-CLI' program is not installed. ABORT$(ansi reset)"
			exit 1
		fi
		read " $(ansi yellow)Do you want to use an encryption key? (otherwise you'll have to give a passphrase) [Y/n]$(ansi reset) " ANSWER
		if [ "$ANSWER" = "" ] || [ "$ANSWER" = "y" ] || [ "$ANSWER" = "Y" ]; then
			CONF_ENCRYPT="key"
			echo " $(ansi dim)Read the documentation to know how to generate an encryption key.$(ansi reset)"
			read -p " $(ansi yellow)Path to your encryption key? [~/.ssh/symkey.bin]$(ansi reset) " ANSWER
			CONF_ENCRYPT_KEY=$(trim "$ANSWER")
			if [ "$CONF_ENCRYP_KEY" = "" ]; then
				CONF_ENCRYPT_KEY="~/.ssh/id_rsa.pem"
			fi
			CONF_ENCRYPT_KEY="$(eval realpath "$CONF_ENCRYPT_KEY")"
			if [ ! -r "$CONF_ENCRYPT_KEY" ]; then
				echo " $(ansi red)⛔ Can't find file '$(ansi reset)$CONF_ENCRYPT_KEY$(ansi red)'. ABORT$(ansi reset)"
				exit 1
			fi
		elif [ "$ANSWER" = "n" ] || [ "$ANSWER" = "N" ]; then
			CONF_ENCRYPT="pass"
			read -s -p " $(ansi yellow)Encryption passphrase ?$(ansi reset) " ANSWER
			CONF_ENCRYPT_PASS=$(trim "$ANSWER")
			if [ "$CONF_ENCRYPT_PASS" = "" ]; then
				echo " $(ansi red)⛔ Empty passphrase. ABORT$(ansi reset)"
				exit 1
			fi
		else
			echo " $(ansi red)⛔ Bad value. ABORT$(ansi reset)"
			exit 1
		fi
	fi
	# BACKUP
	echo
	echo "$(ansi rev blue) BACKUP                  $(ansi reset)"
	# path to backup
	read -p " $(ansi yellow)Paths (directories and/or files) to backup? (separated with spaces) [/etc /home]$(ansi reset) " ANSWER
	CONF_SRC=$(trim "$ANSWER")
	if [ "$CONF_SRC" = "" ]; then
		CONF_SRC="/etc /home"
	fi
	# check paths
	for SRC in $CONF_SRC; do
		if [ "${SRC:0:1}" != "/" ]; then
			echo " $(ansi red)⛔ All paths must begin with a '$(ansi reset)/$(ansi red)'. ABORT$(ansi reset)"
			exit 1
		fi
	done
	# MySQL
	CONF_MYSQL="no"
	read -p " $(ansi yellow)Backup MySQL databases? [Y/n]$(ansi reset) " ANSWER
	ANSWER=$(trim "$ANSWER")
	if [ "$ANSWER" = "" ] || [ "$ANSWER" = "y" ] || [ "$ANSWER" = "Y" ]; then
		read -p " $(ansi yellow)SQL dumps or binary backup? [S/b]$(ansi reset) " ANSWER
		ANSWER=$(trim "$ANSWER")
		if [ "$ANSWER" = "" ] || [ "$ANSWER" = "s" ] || [ "$ANSWER" = "S" ]; then
			if ! type mysqldump > /dev/null; then
				echo " $(ansi red)⛔ The '$(ansi reset)mysqldump$(ansi red)' program is not installed. ABORT$(ansi reset)"
				exit 1
			fi
			CONF_MYSQL="mysqldump"
		elif [ "$ANSWER" = "b" ] || [ "$ANSWER" = "B" ]; then
			if ! type xtrabackup > /dev/null; then
				echo " $(ansi red)⛔ The '$(ansi reset)xtrabackup$(ansi red)' program is not installed. ABORT$(ansi reset)"
				exit 1
			fi
			CONF_MYSQL="xtrabackup"
		else
			echo " $(ansi red)⛔ Bad value. ABORT$(ansi reset)"
			exit 1
		fi
		# MySQL hostname
		read -p " $(ansi yellow)MySQL hostname? [localhost]$(ansi reset) " ANSWER
		CONF_MYSQL_HOST=$(trim "$ANSWER")
		if [ "$CONF_MYSQL_HOST" = "" ]; then
			CONF_MYSQL_HOST="localhost"
		fi
		# MySQL user
		read -p " $(ansi yellow)MySQL user? [root] $(ansi reset) " ANSWER
		CONF_MYSQL_USER=$(trim "$ANSWER")
		if [ "$CONF_MYSQL_USER" = "" ]; then
			CONF_MYSQL_USER="root"
		fi
		# MySQL password
		read -s -p " $(ansi yellow)MySQL password?$(ansi reset) " ANSWER
		CONF_MYSQL_PWD=$(trim "$ANSWER")
		if [ "$CONF_MYSQL_PWD" = "" ]; then
			echo " $(ansi red)⛔ Empty password. ABORT$(ansi reset)"
			exit 1
		fi
		echo
		# mysqldump specific questions
		if [ "$CONF_MYSQL" = "mysqldump" ]; then
			# MySQL databases
			read -p " $(ansi yellow)Do you want to backup all databases readable by this user? (otherwise you will have to give a list of database names) [Y/n]$(ansi reset) " ANSWER
			ANSWER=$(trim "$ANSWER")
			CONF_MYSQL_ALL_DATABASES="yes"
			if [ "$ANSWER" = "n" ] || [ "$ANSWER" = "N" ]; then
				CONF_MYSQL_ALL_DATABASES="no"
				read -p " $(ansi yellow)List of databases? (separated with space characters)$(ansi reset) " ANSWER
				CONF_MYSQL_DATABASES=$(trim "$ANSWER")
				if [ "$CONF_MYSQL_DATABASES" = "" ]; then
					echo " $(ansi red)⛔ No database to backup. ABORT$(ansi reset)"
					exit 1
				fi
			fi
		fi
		# xtrabackup specific questions
		if [ "$CONF_MYSQL" = "xtrabackup" ]; then
			CONF_XTRABACKUP_TYPE="full"
			CONF_XTRABACKUP_LSN_FILE="$CONFIG_FILE_PATH.lsn"
			MSG="Path to the LSN file that will be written?"
			# full or incremental
			read -p " $(ansi yellow)Full or incremental backup? [F/i]$(ansi reset) " ANSWER
			ANSWER=$(trim "$ANSWER")
			if [ "$ANSWER" = "i" ] || [ "$ANSWER" = "I" ]; then
				CONF_XTRABACKUP_TYPE="incremental"
				MSG="Path to the LSN file that will be read and updated?"
			fi
			# path to the LSN file
			read -p " $(ansi yellow)$MSG (needed for subsequent incremental backups) [$CONF_XTRABACKUP_LSN_FILE]$(ansi reset) " ANSWER
			ANSWER=$(trim "$ANSWER")
			if [ "$ANSWER" != "" ]; then
				CONF_XTRABACKUP_LSN_FILE="$ANSWER"
			fi
		fi
	elif [ "$ANSWER" != "n" ] && [ "$ANSWER" != "N" ]; then
		echo " $(ansi red)⛔ Bad value. ABORT$(ansi reset)"
		exit 1
	fi
	# ARCHIVE
	echo
	echo "$(ansi rev magenta) ARCHIVE                 $(ansi reset)"
	# local archive path
	read -p " $(ansi yellow)Path to local archives? [/var/archives]$(ansi reset) " ANSWER
	CONF_BACKUP_PATH=$(trim "$ANSWER")
	if [ "$CONF_BACKUP_PATH" = "" ]; then
		CONF_BACKUP_PATH="/var/archives"
	fi
	CONF_BACKUP_PATH="$(eval realpath "$CONF_BACKUP_PATH")"
	if [ ! -d "$CONF_BACKUP_PATH" ]; then
		read -p " $(ansi yellow)Directory '$(ansi reset)$CONF_BACKUP_PATH$(ansi yellow)' doesn't exist. Create it? [Y/n]$(ansi reset) " ANSWER
		if [ "$ANSWER" = "n" ] || [ "$ANSWER" = "N" ]; then
			echo " $(ansi red)⛔ ABORT$(ansi reset)"
			exit 1
		fi
		if ! mkdir -p "$CONF_BACKUP_PATH"; then
			echo " $(ansi red)⛔ Unable to create directory '$(ansi reset)$CONF_BACKUP_PATH$(ansi red)'. ABORT$(ansi reset)"
			exit 1
		fi
		chmod 700 "$CONF_BACKUP_PATH"
		if [ $? -ne 0 ]; then
			echo " $(ansi red)⛔ Unable to change permissions of directory '$(ansi reset)$CONF_BACKUP_PATH$(ansi red)'. ABORT$(ansi reset)"
			exit 1
		fi
	elif [ ! -w "$CONF_BACKUP_PATH" ]; then
		echo " $(ansi red)⛔ Directory '$(ansi reset)$CONF_BACKUP_PATH$(ansi red)' exists but is not writable. ABORT$(ansi reset)"
		exit 1
	fi
	# Amazon S3 + Glacier
	CONF_AWS_S3="no"
	CONF_AWS_GLACIER="no"
	read -p " $(ansi yellow)Archive to Amazon S3? [Y/n]$(ansi reset) " ANSWER
	if [ "$ANSWER" != "n" ] && [ "$ANSWER" != "N" ]; then
		CONF_AWS_S3="yes"
		# check aws-cli
		if ! type aws > /dev/null; then
			echo " $(ansi red)⛔ The 'AWS-CLI' program is not installed. ABORT$(ansi reset)"
			exit 1
		fi
		# Amazon S3
		read -p " $(ansi yellow)S3 Bucket name?$(ansi reset) " ANSWER
		CONF_S3_BUCKET=$(trim "$ANSWER")
		if [ "$CONF_S3_BUCKET" = "" ]; then
			echo " $(ansi red)⛔ Empty bucket name. ABORT$(ansi reset)"
			exit 1
		fi
		# Amazon Glacier
		read -p " $(ansi yellow)Archive to Amazon Glacier? [Y/n]$(ansi reset) " ANSWER
		if [ "$ANSWER" != "n" ] && [ "$ANSWER" != "N" ]; then
			CONF_AWS_GLACIER="yes"
			read -p " $(ansi yellow)Glacier Vault name?$(ansi reset) " ANSWER
			CONF_GLACIER_VAULT=$(trim "$ANSWER")
			if [ "$CONF_GLACIER_VAULT" = "" ]; then
				echo " $(ansi red)⛔ Empty vault name. ABORT$(ansi reset)"
				exit 1
			fi
		fi
	fi
	# PURGE
	echo
	echo "$(ansi rev red) PURGE                   $(ansi reset)"
	# local purge
	if [ "$SIMPLE_MODE" = "yes" ]; then
		# daily backups
		read -p " $(ansi yellow)Delay for local purge?$(ansi reset) $(ansi dim)(examples: \"$(ansi reset)3 days$(ansi dim)\" \"$(ansi reset)2 weeks$(ansi dim)\" \"$(ansi reset)2 months$(ansi dim)\")$(ansi reset) " ANSWER
	else
		# hourly backups
		echo " $(ansi yellow)Delay for local purge$(ansi reset)"
		echo " $(ansi dim)You can give as many delays as you want, separated by semi-colons.$(ansi reset)"
		echo " $(ansi dim)Each delay could be written like:$(ansi reset)"
		echo " $(ansi dim)   - A number followed by a duration. Examples: \"3 days\", \"2 weeks\", \"2 months\"$(ansi reset)"
		echo " $(ansi dim)   - Same as previous, followed by a colon and some hours to purge (separated by comas). Example: \"2 days:02,04,06,08,10;4 days,01,03,05\"$(ansi reset)"
		echo " $(ansi dim)$(ansi bold)Advice:$(ansi reset)$(ansi dim) Even if you purge on different hours, be sure to purge everything after a given delay.$(ansi reset)"
		echo " $(ansi dim)        Like \"2 days:01,03,05,07,09,11,13,15,17,19,21,23;1 week:02,04,06,10,12,14,18,20,22;2 weeks:08,16;$(ansi under)1 month$(ansi reset)$(ansi dim)\"$(ansi reset)"
		read ANSWER
	fi
	CONF_LOCAL_PURGE_DELAY=$(trim "$ANSWER")
	if [ "$CONF_LOCAL_PURGE_DELAY" = "" ]; then
		read -p " $(ansi red)⚠ Are you sure you want to never purge any backup file? [y/N]$(ansi reset) " ANSWER
		if [ "$ANSWER" != "y" ] && [ "$ANSWER" != "Y" ]; then
			echo " $(ansi red)⛔ Empty purge delay. ABORT$(ansi reset)"
			exit 1
		fi
	fi
	# S3 purge
	if [ "$CONF_AWS_S3" = "yes" ]; then
		if [ "$SIMPLE_MODE" = "yes" ]; then
			# daily backups
			read -p " $(ansi yellow)Delay for Amazon S3 purge?$(ansi reset) $(ansi dim)(examples: \"$(ansi reset)3 days$(ansi dim)\" \"$(ansi reset)2 weeks$(ansi dim)\" \"$(ansi reset)2 months$(ansi dim)\")$(ansi reset) " ANSWER
		else
			# hourly backups
			echo " $(ansi yellow)Delay for Amazon S3 purge$(ansi reset)"
			echo " $(ansi dim)You can give as many delays as you want, separated by semi-colons.$(ansi reset)"
			echo " $(ansi dim)Each delay could be written like:$(ansi reset)"
			echo " $(ansi dim)   - A number followed by a duration. Examples: \"3 days\", \"2 weeks\", \"2 months\"$(ansi reset)"
			echo " $(ansi dim)   - Same as previous, followed by a colon and some hours to purge (separated by comas). Example: \"2 days:02,04,06,08,10;4 days,01,03,05\"$(ansi reset)"
			echo " $(ansi dim)$(ansi bold)Advice:$(ansi reset)$(ansi dim) Even if you purge on different hours, be sure to purge everything after a given delay.$(ansi reset)"
			echo " $(ansi dim)        Like \"1 week:01,02,03,05,06,07,09,10,11,13,14,15,17,18,19,21,22,23;2 weeks:00,08,16;1 month:12,20;$(ansi under)2 months$(ansi reset)$(ansi dim)\"$(ansi reset)"
			read ANSWER
		fi
		CONF_S3_PURGE_DELAY=$(trim "$ANSWER")
		if [ "$CONF_S3_PURGE_DELAY" = "" ]; then
			read -p " $(ansi red)⚠ Are you sure you want to never purge any archived file? [y/N] " ANSWER
			if [ "$ANSWER" != "y" ] && [ "$ANSWER" != "Y" ]; then
				echo " $(ansi red)⛔ Empty purge delay. ABORT$(ansi reset)"
				exit 1
			fi
		fi
	fi
	# GENERATED CONFIG
	echo
	echo "$(ansi rev green) CONFIG CHECK            $(ansi reset)"
	# create result
	RESULT="$(_create_config hide)"
	# display result
	echo
	echo " $(ansi under)HERE IS THE CONTENT THAT WILL BE WRITTEN$(ansi reset)"
	echo "$(ansi dim)$RESULT$(ansi reset)"
	echo
	# write content
	read -p " $(ansi yellow)Ready to erase file '$(ansi reset)$CONFIG_FILE_PATH$(ansi yellow)' and rebuild it? [y/N]$(ansi reset) " ANSWER
	ANSWER=$(trim "$ANSWER")
	if [ "$ANSWER" != "y" ] && [ "$ANSWER" != "Y" ] && [ "$ANSWER" != "yes" ] && [ "$ANSWER" != "YES" ] && [ "$ANSWER" != "Yes" ]; then
		echo
		echo " $(ansi yellow)⚠️  Warning. You will lose the configuration you are editing.$(ansi reset)"
		read -p " Do you really want to $(ansi red)abort$(ansi reset)? [Y/n] " ANSWER
		if [ "$ANSWER" != "n" ] && [ "$ANSWER" != "N" ] && [ "$ANSWER" != "no" ] && [ "$ANSWER" != "NO" ] && [ "$ANSWER" != "No" ]; then
			echo " $(ansi red)⛔ ABORT$(ansi reset)"
			exit 1
		fi
	fi
	RESULT="$(_create_config)"
	echo "$RESULT" > "$(eval realpath "$CONFIG_FILE_PATH")"
	if [ $? -ne 0 ]; then
		echo " $(ansi red)⛔ Unable to create the file '$(ansi reset)$CONFIG_FILE_PATH$(ansi red)'. ABORT$(ansi reset)"
		exit 1
	fi
	chmod 600 "$(eval realpath "$CONFIG_FILE_PATH")"
	if [ $? -ne 0 ]; then
		echo " $(ansi yellow)⚠ Unable to set access rights of the file '$(ansi reset)$CONFIG_FILE_PATH$(ansi yellow)'.$(ansi reset)"
	fi
	echo " $(ansi green)✓ The configuration file '$(ansi reset)$CONFIG_FILE_PATH$(ansi green)' was successfully created.$(ansi reset)"
	# CRONTAB
	echo
	echo "$(ansi rev cyan) CRONTAB                 $(ansi reset)"
	IN_CRONTAB=$(crontab -l 2>/dev/null | grep arkiv | wc -l)
	if [ "$IN_CRONTAB" != "0" ]; then
		read -p " $(ansi yellow)Arkiv is already defined in Crontab. Do you want to remove it and re-define it? [Y/n]$(ansi reset) " ANSWER
	else
		read -p " $(ansi yellow)Do you want to add execution in Crontab? [Y/n]$(ansi reset) " ANSWER
	fi
	ANSWER=$(trim "$ANSWER")
	if [ "$ANSWER" != "" ] && [ "$ANSWER" != "y" ] && [ "$ANSWER" != "Y" ] && [ "$ANSWER" != "n" ] && [ "$ANSWER" != "N" ]; then
		read -p " $(ansi yellow)⚠️  Bad value. Please try again [Y/n]$(ansi reset) " ANSWER
		if [ "$ANSWER" != "" ] && [ "$ANSWER" != "y" ] && [ "$ANSWER" != "Y" ] && [ "$ANSWER" != "n" ] && [ "$ANSWER" != "N" ]; then
			echo " $(ansi red)⛔ Bad value. ABORT$(ansi reset)"
			exit 1
		fi
	fi
	if [ "$ANSWER" != "n" ] && [ "$ANSWER" != "N" ]; then
		if [ "$SIMPLE_MODE" = "yes" ]; then
			CRON_DAYS="*"
			CRON_HOURS="0"
		else
			# execution days
			echo " $(ansi yellow)What days of the month should Arkiv be launched? [*]$(ansi reset)"
			echo " $(ansi dim)Give dates in Crontab format, like \"1,11,21,31\" or \"1-5,11-15,20-25\" or \"*/2\".$(ansi reset)"
			echo " $(ansi dim)Use \"*\" (default value) to launch Arkiv every day.$(ansi reset)"
			read ANSWER
			if [ "$ANSWER" = "*" ]; then
				CRON_DAYS="*"
			else
				CRON_DAYS=$(trim "$ANSWER")
			fi
			if [ "$CRON_DAYS" = "" ]; then
				CRON_DAYS="*"
			fi
			# execution hours
			echo " $(ansi yellow)What hours of the day should Arkiv be launched? [*]$(ansi reset)"
			echo " $(ansi dim)Give hours in Crontab format, like \"0,4,8,12,16,20\" or \"*/4\" or \"0-4,12-16\".$(ansi reset)"
			echo " $(ansi dim)Use \"*\" (default value) to launch Arkiv every hour.$(ansi reset)"
			read ANSWER
			if [ "$ANSWER" = "*" ]; then
				CRON_HOURS="*"
			else
				CRON_HOURS=$(trim "$ANSWER")
			fi
			if [ "$CRON_HOURS" = "" ]; then
				CRON_HOURS="*"
			fi
		fi
		# exec path
		CRON_EXEC_PATH="$PWD"
		read -p " $(ansi yellow)Path to the $(ansi reset)Arkiv$(ansi yellow) executable program [$CRON_EXEC_PATH]$(ansi reset) " ANSWER
		ANSWER=$(trim "$ANSWER")
		if [ "$ANSWER" != "" ]; then
			CRON_EXEC_PATH="$ANSWER"
		fi
		if [ ! -x "$CRON_EXEC_PATH/arkiv" ]; then
			echo " $(ansi red)⛔ Unable to find the file '$(ansi reset)$CRON_EXEC_PATH/arkiv$(ansi red)'. ABORT$(ansi reset)"
			exit 1
		fi
		# log path
		if [ "$OPT_LOG_PATH" != "" ]; then
			CRON_LOG_PATH="$OPT_LOG_PATH"
		else
			read -p " $(ansi yellow)Path to log file? [/var/log/arkiv/arkiv.log]$(ansi reset) " ANSWER
			CRON_LOG_PATH=$(trim "$ANSWER")
			if [ "$CRON_LOG_PATH" = "" ]; then
				CRON_LOG_PATH="/var/log/arkiv/arkiv.log"
			fi
		fi
		CRON_LOG_DIR=$(dirname "$CRON_LOG_PATH")
		if [ ! -d $CRON_LOG_DIR ]; then
			read -p " $(ansi yellow)Directory '$(ansi reset)$CRON_LOG_DIR$(ansi yellow)' doesn't exist. Create it? [Y/n]$(ansi reset) " ANSWER
			if [ "$ANSWER" = "n" ] || [ "$ANSWER" = "N" ]; then
				echo " $(ansi red)⛔ ABORT$(ansi reset)"
				exit 1
			fi
			if ! mkdir -p $CRON_LOG_DIR; then
				echo " $(ansi red)⛔ Unable to create directory '$(ansi reset)$CRON_LOG_DIR$(ansi red)'. ABORT$(ansi reset)"
				exit 1
			fi
			chmod 770 $CRON_LOG_DIR
		elif [ ! -w $CRON_LOG_DIR ]; then
			echo " $(ansi red)⛔ Directory '$(ansi reset)$CRON_LOG_DIR$(ansi red)' exists but is not writable. ABORT$(ansi reset)"
			exit 1
		fi
		# check
		echo
		echo " $(ansi under)HERE IS THE CRONTAB THAT IS ABOUT TO BE ADDED$(ansi reset)"
		echo "$(ansi dim)# ARKIV backup$(ansi reset)"
		echo "$(ansi dim)0 $CRON_HOURS $CRON_DAYS * * $CRON_EXEC_PATH/arkiv exec --config=$CONFIG_FILE_PATH --log=$CRON_LOG_PATH --no-stdout$(ansi reset)"
		echo
		# add to crontab
		read -p " $(ansi yellow)Is it OK for you? [Y/n]$(ansi reset) " ANSWER
		ANSWER=$(trim "$ANSWER")
		if [ "$ANSWER" = "n" ] || [ "$ANSWER" = "N" ]; then
			echo " $(ansi yellow)⚠ No Crontab installation.$(ansi reset)"
		elif [ "$ANSWER" = "" ] || [ "$ANSWER" = "y" ] || [ "$ANSWER" = "Y" ]; then
			(crontab -l 2>/dev/null | grep -v -e "ARKIV" -e "arkiv"; echo; echo "# ARKIV backup"; echo "0 $CRON_HOURS $CRON_DAYS * * $CRON_EXEC_PATH/arkiv exec --config=$CONFIG_FILE_PATH --log=$CRON_LOG_PATH --no-stdout") | crontab -
			echo " $(ansi green)✓ Arkiv was Successfully added to the Crontab$(ansi reset)"
		else
			echo " $(ansi red)⛔ Bad value. ABORT$(ansi reset)"
			exit 1
		fi
	fi
	# END
	echo
	echo "$(ansi rev) END OF CONFIGURATION    $(ansi reset)"
}

# main_exec()
# Backup files, archive and purge.
main_exec() {
	# get current hour (used during purge process)
	CURRENT_HOUR=$(date +"%H")
	# log
	log -n "$(ansi rev)------------------------------------------------------------$(ansi reset)"
	# configuration
	log "$(ansi bold)Start$(ansi reset)"
	log "├ $(ansi dim)Read config file '$(ansi reset)$CONFIG_FILE_PATH$(ansi dim)'.$(ansi reset)"
	if [ ! -r "$(eval realpath "$CONFIG_FILE_PATH")" ]; then
		err "$(ansi red)⛔ Unable to read file '$(ansi reset)$CONFIG_FILE_PATH$(ansi red)'. ABORT$(ansi reset)"
		exit 1
	else
		. "$(eval realpath "$CONFIG_FILE_PATH")"
	fi
	# create destination directory
	CURRENT_PATH=$(date +%Y-%m-%d/%H:00)
	log "├ $(ansi dim)Create output directory '$(ansi reset)$CONF_BACKUP_PATH/$CURRENT_PATH$(ansi dim)'.$(ansi reset)"
	mkdir -p "$CONF_BACKUP_PATH/$CURRENT_PATH"
	if [ $? -ne 0 ]; then
		err "$(ansi red)⛔ Unable to create directory '$(ansi reset)$CONF_BACKUP_PATH/$CURRENT_PATH$(ansi red)'. ABORT$(ansi reset)"
		exit 1
	fi
	chmod -R 700 "$CONF_BACKUP_PATH/$CURRENT_PATH"
	log "└ $(ansi green)Done$(ansi reset)"
	# list of created files
	FILESLIST=""
	# backup files
	if [ "$CONF_SRC" != "" ]; then
		log "$(ansi bold)Backup files$(ansi reset)"
		# loop on paths to backup
		for SRC in $CONF_SRC; do
			log "├ $(ansi dim)Backup path '$(ansi reset)$SRC$(ansi dim)'.$(ansi reset)"
			FILENAME=$(filenamize "$SRC")
			FILEPATH="$CONF_BACKUP_PATH/$CURRENT_PATH/$FILENAME"
			# remove '/' at the beginning of the path to save, and call tar with "-C /" options to avoid the warning "Removing leading `/' from member names"
			SRC="$(echo "$SRC" | sed 's/^\///')"
			# tar path
			tar cf "$FILEPATH.tar" --exclude-caches --exclude-tag=.arkiv-exclude --exclude-ignore=.arkiv-ignore --exclude-ignore-recursive=.arkiv-ignore-recursive -C / "$SRC"
			if [ $? -ne 0 ]; then
				err "$(ansi yellow)⛔ Unable to tar path '$(ansi reset)/$SRC$(ansi yellow)' to '$(ansi reset)$FILEPATH.tar$(ansi yellow)'.$(ansi reset)"
				exit 1
			fi
			# compress file
			if [ "$CONF_Z_TYPE" = "gzip" ]; then
				FILE_EXT="tar.gz"
			elif [ "$CONF_Z_TYPE" = "bzip2" ]; then
				FILE_EXT="tar.bz2"
			elif [ "$CONF_Z_TYPE" = "xz" ]; then
				FILE_EXT="tar.xz"
			else
				FILE_EXT="tar.zst"
			fi
			echo "$FILEPATH.tar" | xargs $CONF_Z_TYPE -q
			if [ $? -eq 0 ]; then
				# remove the source file (zstd program doesn't remove the source file)
				rm -f "$FILEPATH.tar"
			else
				err "$(ansi yellow)⚠ Unable to compress file '$(ansi reset)$FILEPATH.tar$(ansi yellow)' using '$CONF_Z_TYPE'.$(ansi reset)"
				FILE_EXT="tar"
			fi
			# add to list
			FILESLIST="$FILESLIST $FILEPATH.$FILE_EXT"
			# change file rights
			chmod 600 "$FILEPATH.$FILE_EXT"
		done
		log "└ $(ansi green)Done$(ansi reset)"
	fi
	# database backup using mysqldump
	if [ "$CONF_MYSQL" = "mysqldump" ]; then
		log "$(ansi bold)SQL database backup$(ansi reset)"
		# fetch the list of databases if needed
		if [ "$CONF_MYSQL_ALL_DATABASES" = "yes" ]; then
			log "├ $(ansi dim)Fetch the list of databases$(ansi reset)"
			CONF_MYSQL_DATABASES="$(MYSQL_PWD="$CONF_MYSQL_PWD" mysql -u $CONF_MYSQL_USER -h $CONF_MYSQL_HOST -e "SHOW DATABASES;" | tr -d "| " | grep -v -e Database -e _schema -e mysql -e sys)"
			if [ $? -ne 0 ]; then
				err "$(ansi yellow)⚠ Unable to fetch the list of databases from MySQL.$(ansi reset)"
			fi
		fi
		CONF_MYSQL_DATABASES=$(trim "$CONF_MYSQL_DATABASES")
		if [ "$CONF_MYSQL_DATABASES" = "" ]; then
			err "$(ansi yellow)⚠ No one database to backup.$(ansi reset)"
		else
			# create destination directory
			log "├ $(ansi dim)Create destination directory '$(ansi reset)$CONF_BACKUP_PATH/$CURRENT_PATH/database_sql$(ansi bold)'$(ansi reset)"
			mkdir "$CONF_BACKUP_PATH/$CURRENT_PATH/database_sql"
			if [ $? -ne 0 ]; then
				err "$(ansi red)⛔ Unable to create directory '$(ansi reset)$CONF_BACKUP_PATH/$CURRENT_PATH/database_sql$(ansi red)'. ABORT$(ansi reset)"
				exit 1
			fi
			chmod 700 "$CONF_BACKUP_PATH/$CURRENT_PATH/database_sql"
			# loop on databases
			for DB_NAME in $CONF_MYSQL_DATABASES; do
				# dump MySQL database
				log "├ $(ansi dim)Backup database '$(ansi reset)$DB_NAME$(ansi bold)'$(ansi reset)"
				FILEPATH="$CONF_BACKUP_PATH/$CURRENT_PATH/database_sql/$DB_NAME"
				MYSQL_PWD="$CONF_MYSQL_PWD" mysqldump -u $CONF_MYSQL_USER --single-transaction --no-tablespaces --skip-lock-tables --routines $DB_NAME -h $CONF_MYSQL_HOST > "$FILEPATH.sql"
				if [ $? -ne 0 ]; then
					err "$(ansi yellow)⚠ Unable to dump database '$(ansi reset)$DB_NAME$(ansi yellow)'.$(ansi reset)"
					continue
				fi
				# compress the dumped file
				log "├ $(ansi dim)Compress backup file for '$(ansi reset)$DB_NAME$(ansi bold)'.$(ansi reset)"
				if [ "$CONF_Z_TYPE" = "gzip" ]; then
					FILE_EXT="sql.gz"
				elif [ "$CONF_Z_TYPE" = "bzip2" ]; then
					FILE_EXT="sql.bz2"
				elif [ "$CONF_Z_TYPE" = "xz" ]; then
					FILE_EXT="sql.xz"
				else
					FILE_EXT="sql.zst"
				fi
				echo "$FILEPATH.sql" | xargs $CONF_Z_TYPE -q
				if [ $? -eq 0 ]; then
					# remove the source file (zstd program doesn't remove the source file)
					rm -f "$FILEPATH.sql"
				else
					err "$(ansi yellow)⚠ Unable to compress file '$(ansi reset)$FILEPATH.sql$(ansi yellow)' using '$CONF_Z_TYPE'.$(ansi reset)"
					FILE_EXT="sql"
				fi
				# add to list
				FILESLIST="$FILESLIST $FILEPATH.$FILE_EXT"
				# change file rights
				chmod 600 "$FILEPATH.$FILE_EXT"
			done
			log "└ $(ansi green)Done$(ansi reset)"
		fi
	fi
	# database backup using xtrabackup
	if [ "$CONF_MYSQL" = "xtrabackup" ]; then
		log "$(ansi bold)Binary database backup$(ansi reset)"
		# create destination directory
		log "├ $(ansi dim)Create destination directory '$(ansi reset)$CONF_BACKUP_PATH/$CURRENT_PATH/database_data$(ansi bold)'$(ansi reset)"
		mkdir "$CONF_BACKUP_PATH/$CURRENT_PATH/database_data"
		if [ $? -ne 0 ]; then
			err "$(ansi red)⛔ Unable to create directory '$(ansi reset)$CONF_BACKUP_PATH/$CURRENT_PATH/database_data$(ansi red)'. ABORT$(ansi reset)"
			exit 1
		fi
		chmod 700 "$CONF_BACKUP_PATH/$CURRENT_PATH/database_data"
		# read LSN file if needed
		if [ "$CONF_XTRABACKUP_TYPE" = "incremental" ]; then
			log "├ $(ansi dim)Read LSN file$(ansi reset)"
			LSN=$(cat $CONF_XTRABACKUP_LSN_FILE | head -1)
			LSN=$(trim $LSN)
			if [ "$LSN" = "" ]; then
				err "$(ansi yellow)⚠ Empty LSN file '$(ansi reset)$CONF_XTRABACKUP_LSN_FILE$(ansi yellow)'. Forcing a full binary backup.$(ansi reset)"
				CONF_XTRABACKUP_TYPE="full"
			fi
		fi
		# backup operation
		if [ "$CONF_XTRABACKUP_TYPE" = "full" ]; then
			# full backup
			log "├ $(ansi dim)Full binary backup$(ansi reset)"
			MYSQL_PWD="$CONF_MYSQL_PWD" xtrabackup --backup --target-dir="$CONF_BACKUP_PATH/$CURRENT_PATH/database_data" -u $CONF_MYSQL_USER -h $CONF_MYSQL_HOST > /dev/null 2> "$CONF_BACKUP_PATH/$CURRENT_PATH/database_data/xtrabackup.log"
			if [ $? -ne 0 ]; then
				err "$(ansi red)⛔ Unable to save database. See log '$(ansi reset)$CONF_BACKUP_PATH/$CURRENT_PATH/database_data/xtrabackup.log$(ansi red)'. ABORT$(ansi reset)"
				exit 1
			fi
		elif [ "$CONF_XTRABACKUP_TYPE" = "incremental" ]; then
			# incremental backup
			log "├ $(ansi dim)Incremental binary backup$(ansi reset)"
			MYSQL_PWD="$CONF_MYSQL_PWD" xtrabackup --incremental --incremental-lsn=$LSN --target-dir="$CONF_BACKUP_PATH/$CURRENT_PATH/database_data" -u $CONF_MYSQL_USER -h $CONF_MYSQL_HOST > /dev/null 2> "$CONF_BACKUP_PATH/$CURRENT_PATH/database_data/xtrabackup.log"
			if [ $? -ne 0 ]; then
				err "$(ansi red)⛔ Unable to save database. See log '$(ansi reset)$CONF_BACKUP_PATH/$CURRENT_PATH/database_data/xtrabackup.log$(ansi red)'. ABORT$(ansi reset)"
				exit 1
			fi
		fi
		# write LSN File
		log "├ $(ansi dim)Write LSN file$(ansi reset)"
		grep last_lsn "$CONF_BACKUP_PATH/$CURRENT_PATH/database_data/xtrabackup_checkpoints" | cut -d"=" -f2 > $CONF_XTRABACKUP_LSN_FILE
		# tar directory
		log "├ $(ansi dim)Tar'ing generated files$(ansi reset)"
		tar cf "$CONF_BACKUP_PATH/$CURRENT_PATH/database_data.tar" "$CONF_BACKUP_PATH/$CURRENT_PATH/database_data"
		if [ $? -ne 0 ]; then
			err "$(ansi red)⛔ Unable to tar directory '$(ansi reset)$CONF_BACKUP_PATH/$CURRENT_PATH/database_data$(ansi red)' to '$(ansi reset)$CONF_BACKUP_PATH/$CURRENT_PATH/database_data.tar$(ansi red)'.$(ansi reset)"
			exit 1
		fi
		# compress files
		log "├ $(ansi dim)Compress file$(ansi reset)"
		if [ "$CONF_Z_TYPE" = "gzip" ]; then
			FILE_EXT="tar.gz"
		elif [ "$CONF_Z_TYPE" = "bzip2" ]; then
			FILE_EXT="tar.bz2"
		elif [ "$CONF_Z_TYPE" = "xz" ]; then
			FILE_EXT="tar.xz"
		else
			FILE_EXT="tar.zst"
		fi
		echo "$CONF_BACKUP_PATH/$CURRENT_PATH/database_data.tar" | xargs $CONF_Z_TYPE -q
		if [ $? -ne 0 ]; then
			err "$(ansi yellow)⚠ Unable to compress file '$(ansi reset)$CONF_BACKUP_PATH/$CURRENT_PATH/database_data.tar$(ansi yellow)' using '$CONF_Z_TYPE'.$(ansi reset)"
			FILE_EXT="tar"
		fi
		# remove directory
		rm -rf "$CONF_BACKUP_PATH/$CURRENT_PATH/database_data"
		if [ $? -eq 0 ]; then
			err "$(ansi yellow)⛔ Unable to delete directory '$(ansi reset)$CONF_BACKUP_PATH/$CURRENT_PATH/database_data$(ansi yellow)'.$(ansi reset)"
			exit 1
		fi
		# add to list
		FILESLIST="$FILESLIST $CONF_BACKUP_PATH/$CURRENT_PATH/database_data.$FILE_EXT"
		# change file rights
		chmod 600 "$FILEPATH.$FILE_EXT"
		log "└ $(ansi green)Done$(ansi reset)"
	fi
	# encryption
	FILESLIST_RESULT=""
	if [ "$CONF_ENCRYPT" = "" ]; then
		FILESLIST_RESULT="$FILESLIST"
	else
		for FILE in $FILESLIST; do
			if [ "$CONF_ENCRYPT" = "key" ]; then
				openssl enc -aes-256-cbc -e -salt -in "$FILE" -out "$FILE.encrypt" -pass file:$CONF_ENCRYPT_KEY
			else
				CRYPT_PWD="$CONF_ENCRYPT_PASS" openssl enc -aes-256-cbc -e -salt -in "$FILE" -out "$FILE.encrypt" -pass env:CRYPT_PWD
			fi
			if [ $? -ne 0 ]; then
				err "$(ansi yellow)⚠ Unable to encrypt file '$(ansi reset)$FILE$(ansi yellow)' using '$(ansi reset)$CONF_ENCRYPT$(ansi yellow)'.$(ansi reset)"
				FILESLIST_RESULT="$FILESLIST_RESULT $FILE"
			else
				FILESLIST_RESULT="$FILESLIST_RESULT $FILE.encrypt"
			fi
		done
	fi
	# compute checksums
	log "$(ansi bold)Compute checksums$(ansi reset)"
	sha256sum $FILESLIST_RESULT > "$CONF_BACKUP_PATH/$CURRENT_PATH/sha256sums"
	if [ $? -ne 0 ]; then
		err "$(ansi yellow)⚠ Unable to create SHA256 checksum file '$(ansi reset)$CONF_BACKUP_PATH/$CURRENT_PATH/sha256sums$(ansi yellow)'.$(ansi reset)"
	fi
	# change cheksum file rights
	chmod 600 "$CONF_BACKUP_PATH/$CURRENT_PATH/sha256sums"
	log "└ $(ansi green)Done$(ansi reset)"
	# archive on Amazon Glacier
	if [ "$CONF_AWS_GLACIER" = "yes" ]; then
		log "$(ansi bold)Archiving on Amazon Glacier$(ansi reset)"
		aws glacier upload-archive --account-id - --vault-name $CONF_GLACIER_VAULT --body "$CONF_BACKUP_PATH/$CURRENT_PATH/sha256sums" > "$CONF_BACKUP_PATH/$CURRENT_PATH/sha256sums.glacier.json"
		if [ $? -ne 0 ]; then
			err "$(ansi yellow)⚠ Unable to send file '$(ansi reset)$CONF_BACKUP_PATH/$CURRENT_PATH/sha256sums$(ansi yellow)' to Amazon Glacier.$(ansi reset)"
		fi
		for FILE in $FILESLIST_RESULT; do
			log "├ $(ansi dim)Archive file '$(ansi reset)$FILE$(ansi dim)'.$(ansi reset)"
			aws glacier upload-archive --account-id - --vault-name $CONF_GLACIER_VAULT --body "$FILE" > "$FILE.glacier.json"
			if [ $? -ne 0 ]; then
				err "$(ansi yellow)⚠ Unable to send file '$(ansi reset)$FILE$(ansi yellow)' to Amazon Glacier.$(ansi reset)"
			fi
		done
		log "└ $(ansi green)Done$(ansi reset)"
	fi
	# archive on Amazon S3
	if [ "$CONF_AWS_S3" = "yes" ]; then
		log "$(ansi bold)Archiving on Amazon S3$(ansi reset)"
		aws s3 sync $CONF_BACKUP_PATH/$CURRENT_PATH s3://$CONF_S3_BUCKET/$CONF_LOCAL_HOSTNAME/$CURRENT_PATH --quiet --storage-class STANDARD_IA
		if [ $? -ne 0 ]; then
			err "$(ansi yellow)⚠ Unable to copy directory '$(ansi reset)$CONF_BACKUP_PATH/$CURRENT_PATH$(ansi yellow)' to Amazon S3 '$(ansi reset)$CONF_S3_BUCKET/$CONF_LOCAL_HOSTNAME/$CURRENT_PATH$(ansi yellow)'.$(ansi reset)"
		fi
		log "└ $(ansi green)Done$(ansi reset)"
	fi
	# purge local files
	if [ "$CONF_LOCAL_PURGE_DELAY" != "" ]; then
		log "$(ansi bold)Purge local files$(ansi reset)"
		# list of delays, each one like "2 days" or "3 weeks:01,03,05"
		DELAYS=$(echo "$CONF_LOCAL_PURGE_DELAY" | tr " " "_" | tr ";" "\n")
		# loop on the delays
		for DELAY in $DELAYS; do
			# extract the delay part, like "2 days" or "3 weeks"
			AGO=$(echo "$DELAY" | cut -d":" -f 1 | tr "_" " ")
			# compute the date of the archive(s) to purge
			PURGE_DATE=$(date --date="$AGO ago" +%Y-%m-%d)
			# check if the directory exists
			if [ ! -d "$CONF_BACKUP_PATH/$PURGE_DATE" ]; then
				continue;
			fi
			# check if there is some specified hours
			if [[ $DELAY != *:* ]]; then
				# no specified hour, delete the whole day
				log "├ $(ansi dim)Delete '$(ansi reset)$CONF_BACKUP_PATH/$PURGE_DATE$(ansi dim)'."
				rm -rf "$CONF_BACKUP_PATH/$PURGE_DATE"
				if [ $? -ne 0 ]; then
					err "$(ansi yellow)⚠ Unable to purge local directory '$(ansi reset)$CONF_BACKUP_PATH/$PURGE_DATE$(ansi yellow)'.$(ansi reset)"
				fi
			else
				# get the list of hours to delete
				HOURS=$(echo "$DELAY" | cut -d":" -f 2)
				HOURS=$(trim "$HOURS")
				if [ "$HOURS" = "" ]; then
					continue
				fi
				# loop on the hours
				HOURS=$(echo "$HOURS" | tr "," "\n")
				for HOUR in $HOURS; do
					# get the hour on 2 digits
					HOUR=$(printf "%02d" $(trim "$HOUR" | sed 's/^0//'))
					# continue the loop if this hour is not equal to the current hour, or if the directory was already deleted
					if [ "$HOUR" != "$CURRENT_HOUR" ] || [ ! -d "$CONF_BACKUP_PATH/$PURGE_DATE/$HOUR:00" ]; then
						continue;
					fi
					# delete the directory
					log "├ $(ansi dim)Delete '$(ansi reset)$CONF_BACKUP_PATH/$PURGE_DATE/$HOUR:00$(ansi dim)'."
					rm -rf "$CONF_BACKUP_PATH/$PURGE_DATE/$HOUR:00"
					if [ $? -ne 0 ]; then
						err "$(ansi yellow)⚠ Unable to purge local directory '$(ansi reset)$CONF_BACKUP_PATH/$PURGE_DATE/$HOUR:00$(ansi yellow)'.$(ansi reset)"
					fi
				done
				# delete the whole day's directory if it's empty
				NBR=$(ls -l "$CONF_BACKUP_PATH/$PURGE_DATE" | tail -n +2 | wc -l)
				if [ $NBR -eq 0 ]; then
					log "├ $(ansi dim)Delete '$(ansi reset)$CONF_BACKUP_PATH/$PURGE_DATE$(ansi dim)'."
					rm -rf "$CONF_BACKUP_PATH/$PURGE_DATE"
					if [ $? -ne 0 ]; then
						err "$(ansi yellow)⚠ Unable to purge local directory '$(ansi reset)$CONF_BACKUP_PATH/$PURGE_DATE$(ansi yellow)'.$(ansi reset)"
					fi
				fi
			fi
		done
		log "└ $(ansi green)Done$(ansi reset)"
	fi
	# purge files on Amazon S3
	if [ "$CONF_S3_PURGE_DELAY" != "" ]; then
		log "$(ansi bold)Purge files on Amazon S3$(ansi reset)"
		# list of delays, each one like "2 days" or "3 weeks:01,03,05"
		DELAYS=$(echo "$CONF_S3_PURGE_DELAY" | tr " " "_" | tr ";" "\n")
		# loop on the delays
		for DELAY in $DELAYS; do
			# extract the delay part, like "2 days" or "3 weeks"
			AGO=$(echo "$DELAY" | cut -d":" -f 1 | tr "_" " ")
			# compute the date of the archive(s) to purge
			PURGE_DATE=$(date --date="$AGO ago" +%Y-%m-%d)
			# check if there is some specified hours
			if [[ $DELAY != *:* ]]; then
				# no specified hour, delete the whole day
				log "├ $(ansi dim)Delete '$(ansi reset)s3://$CONF_S3_BUCKET/$CONF_LOCAL_HOSTNAME/$PURGE_DATE$(ansi dim)'."
				aws s3 rm s3://$CONF_S3_BUCKET/$CONF_LOCAL_HOSTNAME/$PURGE_DATE/ --recursive --exclude "sha256sums" --exclude "*.glacier.json"
				if [ $? -ne 0 ]; then
					err "$(ansi yellow)⚠ Unable to purge S3 directory '$(ansi reset)$CONF_S3_BUCKET/$CONF_LOCAL_HOSTNAME/$PURGE_DATE$(ansi yellow)'.$(ansi reset)"
				fi
			else
				# get the list of hours to delete
				HOURS=$(echo "$DELAY" | cut -d":" -f 2)
				HOURS=$(trim "$HOURS")
				if [ "$HOURS" = "" ]; then
					continue
				fi
				# loop on the hours
				HOURS=$(echo "$HOURS" | tr "," "\n")
				for HOUR in $HOURS; do
					# get the hour on 2 digits
					HOUR=$(printf "%02d" $(trim "$HOUR" | sed 's/^0//'))
					# continue the loop if this hour is not equal to the current hour
					if [ "$HOUR" != "$CURRENT_HOUR" ]; then
						continue;
					fi
					# delete the directory
					log "├ $(ansi dim)Delete '$(ansi reset)s3://$CONF_S3_BUCKET/$CONF_LOCAL_HOSTNAME/$PURGE_DATE/$HOUR:00$(ansi dim)'."
					aws s3 rm s3://$CONF_S3_BUCKET/$CONF_LOCAL_HOSTNAME/$PURGE_DATE/$HOUR:00/ --recursive --exclude "sha256sums" --exclude "*.glacier.json"
					if [ $? -ne 0 ]; then
						err "$(ansi yellow)⚠ Unable to purge S3 directory '$(ansi reset)$CONF_S3_BUCKET/$CONF_LOCAL_HOSTNAME/$PURGE_DATE/$HOUR:00$(ansi yellow)'.$(ansi reset)"
					fi
				done
			fi
		done
		log "└ $(ansi green)Done$(ansi reset)"
	fi
	log "$(ansi green)✓ End of processing$(ansi reset)"
	log -n ""
}


# ########## MAIN EXECUTION ##########

# parsing command-line options
case "$1" in
	"config")
		EXEC_TYPE="config"
		;;
	"exec")
		EXEC_TYPE="exec"
		;;
	*)
		main_usage
		;;
esac
shift
while getopts ":c:l:oen-:" OPTCHAR; do
	case "$OPTCHAR" in
		"-")
			case "$OPTARG" in
				config=*)
					CONFIG_FILE_PATH=${OPTARG#*=}
					;;
				log=*)
					OPT_LOG_PATH=${OPTARG#*=}
					;;
				"no-stdout")
					OPT_NOSTDOUT=1
					;;
				"no-stderr")
					OPT_NOSTDERR=1
					;;
				"no-ansi")
					OPT_NOANSI=1
					;;
				"syslog")
					OPT_SYSLOG=1
					;;
				*)
					log "$(ansi red)⛔ Bad command line option '--$OPTARG'. ABORT$(ansi reset)"
					log "$(ansi dim)Try $(ansi reset)$0 help$(ansi dim) to get help.$(ansi reset)"
					exit 1
			esac
			;;
		"c")
			CONFIG_FILE_PATH="$OPTARG"
			;;
		"l")
			OPT_LOG_PATH="$OPTARG"
			;;
		"o")
			OPT_NOSTDOUT=1
			;;
		"e")
			OPT_NOSTDERR=1
			;;
		"n")
			OPT_NOANSI=1
			;;
		"s")
			OPT_SYSLOG=1
			;;
		*)
			log "$(ansi red)⛔ Bad command line option '-$OPTARG'. ABORT$(ansi reset)"
			log "$(ansi dim)Try $(ansi reset)$0 help$(ansi dim) to get help.$(ansi reset)"
			exit 1
			;;
	esac
done
# main execution
case "$EXEC_TYPE" in
	"config")
		main_config
		;;
	"exec")
		main_exec
		;;
	*)
		main_usage
		;;
esac

